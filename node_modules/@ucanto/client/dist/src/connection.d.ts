export function connect<T>(options: API.ConnectionOptions<T>): API.ConnectionView<T>;
export function execute<C extends API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, T, I extends API.Transport.Tuple<API.ServiceInvocation<C, T>>>(invocations: I, connection: API.Connection<T>): Promise<API.InferServiceInvocations<I, T>>;
import * as API from "@ucanto/interface";
/**
 * @template T
 * @implements {API.ConnectionView<T>}
 */
declare class Connection<T> implements API.ConnectionView<T> {
    /**
     * @param {API.ConnectionOptions<T>} options
     */
    constructor(options: API.ConnectionOptions<T>);
    id: API.UCAN.Identity;
    options: API.ConnectionOptions<T>;
    encoder: API.RequestEncoder;
    decoder: API.ResponseDecoder;
    channel: API.Channel<T>;
    hasher: API.UCAN.MultihashHasher<number>;
    /**
     * @template {API.Capability} C
     * @template {API.Tuple<API.ServiceInvocation<C, T>>} I
     * @param {I} invocations
     */
    execute<C extends API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, I extends API.Transport.Tuple<API.ServiceInvocation<C, T>>>(...invocations: I): Promise<API.InferServiceInvocations<I, T>>;
}
export {};
//# sourceMappingURL=connection.d.ts.map