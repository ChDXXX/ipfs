export function open<T>({ url, method, fetch }: {
    url: URL;
    fetch?: ((url: string, init: API.HTTPRequest<API.Transport.Tuple<API.ServiceInvocation<API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, {
        [x: string]: {
            [x: string]: API.ServiceMethod<API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, any, any>;
        };
    } | {
        "*": API.ServiceMethod<API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, any, any>;
    }>>>) => API.Await<FetchResponse>) | undefined;
    method?: string | undefined;
}): API.Channel<T>;
export type FetchResponse = {
    ok: boolean;
    arrayBuffer(): API.Await<ArrayBuffer>;
    headers: {
        entries(): Iterable<[string, string]>;
    };
    status?: number;
    statusText?: string;
    url?: string;
};
export type Fetcher = Fetcher;
export type Options = {
    status?: number;
    statusText?: string;
    url?: string;
};
import * as API from "@ucanto/interface";
declare class Channel {
    /**
     * @param {object} options
     * @param {URL} options.url
     * @param {Fetcher} options.fetch
     * @param {string} [options.method]
     */
    constructor({ url, fetch, method }: {
        url: URL;
        fetch: Fetcher;
        method?: string | undefined;
    });
    fetch: Fetcher;
    method: string | undefined;
    url: URL;
    /**
     * @param {API.HTTPRequest} request
     * @returns {Promise<API.HTTPResponse>}
     */
    request({ headers, body }: API.HTTPRequest): Promise<API.HTTPResponse>;
}
export {};
//# sourceMappingURL=http.d.ts.map