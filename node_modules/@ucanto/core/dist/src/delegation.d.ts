export function isLink(value: API.Proof): value is UCAN.Proof<UCAN.Capability<UCAN.Ability, `${string}:${string}`>, number>;
export function isDelegation(proof: API.Proof): proof is API.Delegation<[UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]]>;
/**
 * Represents UCAN chain view over the set of DAG UCAN nodes. You can think of
 * this as UCAN interface of the CAR.
 *
 * @template {[API.Capability, ...API.Capability[]]} C
 * @implements {API.Delegation<C>}
 * @extends {DelegationView<C>}
 */
export class Delegation<C extends [UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]]> implements API.Delegation<C> {
    /**
     * @param {API.Block<C>} root
     * @param {Map<string, API.Block>} [blocks]
     */
    constructor(root: API.Block<C>, blocks?: Map<string, API.Block<[UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]], number>> | undefined);
    root: API.Block<C, number>;
    blocks: Map<string, API.Block<[UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]], number>>;
    get version(): `${number}.${number}.${number}`;
    get signature(): UCAN.Signature<UCAN.SignPayload<C[number]>, number>;
    get cid(): UCAN.Proof<C[number], number>;
    get asCID(): UCAN.Proof<C[number], number>;
    get bytes(): UCAN.ByteView<UCAN.UCAN<C[number]>>;
    get data(): UCAN.View<C[number]>;
    export(): IterableIterator<API.Block<[UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]], number>>;
    /**
     * @type {API.Proof[]}
     */
    get proofs(): API.Proof<[UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]]>[];
    /**
     * @type {API.Identity}
     */
    get issuer(): UCAN.Identity;
    /**
     * @type {API.Identity}
     */
    get audience(): UCAN.Identity;
    /**
     * @returns {C}
     */
    get capabilities(): C;
    /**
     * @returns {number}
     */
    get expiration(): number;
    /**
     * @returns {undefined|number}
     */
    get notBefore(): number | undefined;
    /**
     * @returns {undefined|string}
     */
    get nonce(): string | undefined;
    /**
     * @returns {API.Fact[]}
     */
    get facts(): UCAN.Fact[];
    /**
     * Iterate over the proofs
     *
     * @returns {IterableIterator<API.Delegation>}
     */
    iterate(): IterableIterator<API.Delegation>;
}
export function delegate<A extends number, C extends [UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]]>({ issuer, audience, proofs, ...input }: API.DelegationOptions<C, A>, options?: API.EncodeOptions | undefined): Promise<API.Delegation<C>>;
export function importDAG<C extends [UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]]>(dag: Iterable<API.Block & {
    data?: UCAN.UCAN;
}>): API.Delegation<C>;
export function create<C extends [UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]]>({ root, blocks }: {
    root: API.Block<C, number>;
    blocks?: Map<string, API.Block<[UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]], number>> | undefined;
}): API.Delegation<C>;
import * as API from "@ucanto/interface";
import * as UCAN from "@ipld/dag-ucan/src/lib";
/**
 * @template {[API.Capability, ...API.Capability[]]} C
 * @param {API.Block<C>} root
 * @param {Map<string, API.Block>} blocks
 * @returns {IterableIterator<API.Block>}
 */
declare function exportDAG<C extends [UCAN.Capability<UCAN.Ability, `${string}:${string}`>, ...UCAN.Capability<UCAN.Ability, `${string}:${string}`>[]]>(root: API.Block<C, number>, blocks: Map<string, API.Block>): IterableIterator<API.Block>;
export { exportDAG as export, _export as export, importDAG as import, _import as import, Delegation as View };
//# sourceMappingURL=delegation.d.ts.map