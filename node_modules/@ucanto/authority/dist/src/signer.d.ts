export const code: 4864;
export const name: "Ed25519";
export function generate(): Promise<API.SigningAuthority<typeof Authority.code>>;
export function derive(secret: Uint8Array): Promise<API.SigningAuthority<typeof Authority.code>>;
export function decode(bytes: Uint8Array): SigningAuthority;
export function encode({ bytes }: API.SigningAuthority<typeof Authority.code>): Uint8Array;
export function format<Prefix extends string>({ bytes }: API.SigningAuthority<typeof Authority.code>, encoder?: API.UCAN.MultibaseEncoder<Prefix> | undefined): string;
export function parse<Prefix extends string>(signingAuthority: string, decoder?: API.MultibaseDecoder<Prefix> | undefined): API.SigningAuthority<typeof Authority.code>;
export function did({ authority }: API.SigningAuthority<typeof Authority.code>): API.DID;
import * as API from "@ucanto/interface";
/**
 * @implements {API.SigningAuthority<typeof Authority.code>}
 */
declare class SigningAuthority implements API.SigningAuthority<typeof Authority.code> {
    /**
     * @param {Uint8Array} bytes
     */
    constructor(bytes: Uint8Array);
    buffer: ArrayBufferLike;
    byteOffset: number;
    byteLength: number;
    bytes: Uint8Array;
    get authority(): API.Authority<237>;
    /**
     * Raw public key without multiformat code.
     */
    get secret(): Uint8Array;
    /**
     * DID of the authority in `did:key` format.
     *
     * @returns {API.DID}
     */
    did(): API.DID;
    /**
     * @template T
     * @param {API.ByteView<T>} payload
     * @returns {Promise<API.Signature<T, typeof Authority.code>>}
     */
    sign<T>(payload: API.UCAN.ByteView<T>): Promise<API.UCAN.Signature<T, 237>>;
    /**
     * @template T
     * @param {API.ByteView<T>} payload
     * @param {API.Signature<T, typeof Authority.code>} signature
     */
    verify<T_1>(payload: API.UCAN.ByteView<T_1>, signature: API.UCAN.Signature<T_1, 237>): API.UCAN.Await<boolean>;
}
import * as Authority from "./authority.js";
export {};
//# sourceMappingURL=signer.d.ts.map