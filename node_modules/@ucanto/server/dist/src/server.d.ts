export function create<Service>(options: API.Server<Service>): API.ServerView<Service>;
export function handle<T, C extends API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, I extends API.Transport.Tuple<API.ServiceInvocation<C, T>>>(server: API.ServerView<T>, request: API.HTTPRequest<I>): Promise<API.HTTPResponse<API.InferServiceInvocations<I, T>>>;
export function execute<Service, C extends API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, I extends API.Transport.Tuple<API.ServiceInvocation<C, Service>>>(invocations: API.InferInvocations<I>, server: API.ServerView<Service>): Promise<API.InferServiceInvocations<I, Service>>;
export function invoke<Service, C extends API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>>(invocation: API.InferInvocation<API.ServiceInvocation<C, Service>>, server: API.ServerView<Service>): Promise<API.InferServiceInvocationReturn<C, Service>>;
/**
 * @implements {API.HandlerNotFound}
 */
export class HandlerNotFound extends RangeError implements API.HandlerNotFound {
    /**
     * @param {API.Capability} capability
     */
    constructor(capability: API.Capability);
    /** @type {true} */
    error: true;
    capability: API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>;
    /** @type {'HandlerNotFound'} */
    get name(): "HandlerNotFound";
    get message(): string;
    toJSON(): {
        name: "HandlerNotFound";
        error: true;
        capability: {
            can: API.UCAN.Ability;
            with: `${string}:${string}`;
        };
        message: string;
        stack: string | undefined;
    };
}
import * as API from "@ucanto/interface";
/**
 * @template Service
 * @implements {API.ServerView<Service>}
 */
declare class Server<Service> implements API.ServerView<Service> {
    /**
     * @param {API.Server<Service>} options
     */
    constructor({ id, service, encoder, decoder, catch: fail, authority, canIssue, ...context }: API.Server<Service>);
    context: {
        my?: ((issuer: API.UCAN.DID<unknown>) => API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>[]) | undefined;
        resolve?: ((proof: API.UCAN.Proof<API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, number>) => API.Await<API.Result<API.Delegation<[API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, ...API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>[]]>, API.UnavailableProof>>) | undefined;
        id: API.UCAN.Identity;
        authority: API.AuthorityParser<number>;
        canIssue: (capability: API.ParsedCapability<API.UCAN.Ability, API.URI<`${string}:`>, {}>, issuer: API.UCAN.DID<unknown>) => boolean;
    };
    service: Service;
    encoder: API.ResponseEncoder;
    decoder: API.RequestDecoder;
    catch: (err: API.HandlerExecutionError) => void;
    get id(): API.UCAN.Identity;
    /**
     * @template {API.Capability} C
     * @template {API.Tuple<API.ServiceInvocation<C, Service>>} I
     * @param {API.HTTPRequest<I>} request
     * @returns {API.Await<API.HTTPResponse<API.InferServiceInvocations<I, Service>>>}
     */
    request<C extends API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, I extends API.Transport.Tuple<API.ServiceInvocation<C, Service>>>(request: API.HTTPRequest<I>): API.Await<API.HTTPResponse<API.InferServiceInvocations<I, Service>>>;
}
export { capability, URI, Link, Failure, MalformedCapability } from "@ucanto/validator";
//# sourceMappingURL=server.d.ts.map