export function capability<A extends API.UCAN.Ability, R extends API.URI<`${string}:`>, C extends API.Caveats = {}>(descriptor: API.Descriptor<A, R, C>): API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>;
export function or<M extends API.Match<any, API.UnknownMatch>, W extends API.Match<any, API.UnknownMatch>>(left: API.Matcher<M>, right: API.Matcher<W>): API.CapabilityParser<M | W>;
export function and<Selectors extends API.MatchSelector<API.Match<any, API.UnknownMatch>>[]>(...selectors: Selectors): API.CapabilitiesParser<API.InferMembers<Selectors>>;
export function derive<M extends API.Match<any, API.UnknownMatch>, T extends API.ParsedCapability<API.UCAN.Ability, API.URI<`${string}:`>, any>>({ from, to, derives }: API.DeriveSelector<M, T> & {
    from: API.MatchSelector<M>;
}): API.TheCapabilityParser<API.DerivedMatch<T, M>>;
import * as API from "@ucanto/interface";
/**
 * @template {API.ParsedCapability} T
 * @template {API.Match} M
 * @implements {API.DerivedMatch<T, M>}
 */
declare class DerivedMatch<T extends API.ParsedCapability<API.UCAN.Ability, API.URI<`${string}:`>, any>, M extends API.Match<any, API.UnknownMatch>> implements API.DerivedMatch<T, M> {
    /**
     * @param {API.DirectMatch<T>} selected
     * @param {API.MatchSelector<M>} from
     * @param {API.Derives<T, M['value']>} derives
     */
    constructor(selected: API.DirectMatch<T>, from: API.MatchSelector<M>, derives: API.Derives<T, M['value']>);
    selected: API.DirectMatch<T>;
    from: API.MatchSelector<M>;
    derives: API.Derives<T, M["value"]>;
    get can(): API.UCAN.Ability;
    get source(): API.Source[];
    get proofs(): API.Delegation<[API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, ...API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>[]]>[];
    get value(): T;
    /**
     * @param {API.CanIssue} context
     */
    prune(context: API.CanIssue): DerivedMatch<T, M> | null;
    /**
     * @param {API.Source[]} capabilities
     */
    select(capabilities: API.Source[]): {
        unknown: API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>[];
        errors: (MatchError | API.DelegationError)[];
        matches: (DerivedMatch<T, M> | M)[];
    };
    toString(): string;
}
import { DelegationError as MatchError } from "./error.js";
export {};
//# sourceMappingURL=capability.d.ts.map