export { capability } from "./capability.js";
export * as URI from "./decoder/uri.js";
export * as Link from "./decoder/link.js";
export function access<A extends API.UCAN.Ability, R extends API.URI<`${string}:`>, C extends API.Caveats, T extends API.ParsedCapability<A, R, API.InferCaveats<C>>>(invocation: API.Invocation<API.UCAN.Capability<A, R["href"]> & ({ [K_1 in keyof C]: C[K_1] extends API.Decoder<unknown, infer T_2 extends unknown, infer _ extends {
    error: true;
}> ? T_2 : never; } extends infer T_1 ? { [K in keyof T_1 as { [K_1 in keyof C]: C[K_1] extends API.Decoder<unknown, infer T_2 extends unknown, infer _ extends {
    error: true;
}> ? T_2 : never; }[K] | undefined extends { [K_1 in keyof C]: C[K_1] extends API.Decoder<unknown, infer T_2 extends unknown, infer _ extends {
    error: true;
}> ? T_2 : never; }[K] ? never : K]: { [K_1 in keyof C]: C[K_1] extends API.Decoder<unknown, infer T_2 extends unknown, infer _ extends {
    error: true;
}> ? T_2 : never; }[K]; } : never) & ({ [K_1 in keyof C]: C[K_1] extends API.Decoder<unknown, infer T_2 extends unknown, infer _ extends {
    error: true;
}> ? T_2 : never; } extends infer T_3 ? { [K_2 in keyof T_3 as { [K_1 in keyof C]: C[K_1] extends API.Decoder<unknown, infer T_2 extends unknown, infer _ extends {
    error: true;
}> ? T_2 : never; }[K_2] | undefined extends { [K_1 in keyof C]: C[K_1] extends API.Decoder<unknown, infer T_2 extends unknown, infer _ extends {
    error: true;
}> ? T_2 : never; }[K_2] ? K_2 : never]?: { [K_1 in keyof C]: C[K_1] extends API.Decoder<unknown, infer T_2 extends unknown, infer _ extends {
    error: true;
}> ? T_2 : never; }[K_2] | undefined; } : never)>, { canIssue, authority, my, resolve, capability }: API.ValidationOptions<T>): Promise<API.Result<Authorization<T>, API.Unauthorized>>;
export function authorize<C extends API.ParsedCapability<API.UCAN.Ability, API.URI<`${string}:`>, any>, Match extends API.Match<any, API.UnknownMatch>>(match: Match, config: Required<API.ValidationOptions<C>>): Promise<API.Result<Authorization<API.ParsedCapability>, API.InvalidClaim>>;
import { Failure } from "./error.js";
import { UnavailableProof } from "./error.js";
import { MalformedCapability } from "./error.js";
import * as API from "@ucanto/interface";
/**
 * @template {API.ParsedCapability} C
 */
declare class Authorization<C extends API.ParsedCapability<API.UCAN.Ability, API.URI<`${string}:`>, any>> {
    /**
     * @param {API.Match<C>} match
     * @param {Authorization<API.ParsedCapability>[]} proofs
     */
    constructor(match: API.Match<C>, proofs: Authorization<API.ParsedCapability>[]);
    match: API.Match<C, API.UnknownMatch>;
    proofs: Authorization<API.ParsedCapability<API.UCAN.Ability, API.URI<`${string}:`>, any>>[];
    get capability(): C;
    get delegation(): API.Delegation<[API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, ...API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>[]]>;
    get issuer(): API.UCAN.Identity;
    get audience(): API.UCAN.Identity;
}
/**
 * @implements {API.Unauthorized}
 */
declare class Unauthorized extends Failure implements API.Unauthorized {
    /**
     * @param {API.InvalidCapability | API.InvalidProof | API.InvalidClaim} cause
     */
    constructor(cause: API.InvalidCapability | API.InvalidProof | API.InvalidClaim);
    /** @type {"Unauthorized"} */
    name: "Unauthorized";
    cause: API.InvalidCapability | API.InvalidClaim | API.InvalidProof;
    toJSON(): {
        error: true;
        name: "Unauthorized";
        message: string;
        cause: API.InvalidCapability | API.InvalidClaim | API.InvalidProof;
    };
}
/**
 * @implements {API.InvalidClaim}
 */
declare class InvalidClaim extends Failure implements API.InvalidClaim {
    /**
     * @param {{
     * match: API.Match
     * delegationErrors: API.DelegationError[]
     * unknownCapaibilities: API.Capability[]
     * invalidProofs: ProofError[]
     * failedProofs: API.InvalidClaim[]
     * }} info
     */
    constructor(info: {
        match: API.Match;
        delegationErrors: API.DelegationError[];
        unknownCapaibilities: API.Capability[];
        invalidProofs: ProofError[];
        failedProofs: API.InvalidClaim[];
    });
    info: {
        match: API.Match;
        delegationErrors: API.DelegationError[];
        unknownCapaibilities: API.Capability[];
        invalidProofs: ProofError[];
        failedProofs: API.InvalidClaim[];
    };
    /** @type {"InvalidClaim"} */
    name: "InvalidClaim";
    get issuer(): API.UCAN.Identity;
    get capability(): any;
    get delegation(): API.Delegation<[API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>, ...API.UCAN.Capability<API.UCAN.Ability, `${string}:${string}`>[]]>;
}
import { InvalidAudience } from "./error.js";
import { DelegationError } from "./error.js";
declare class ProofError extends Failure {
    /**
     * @param {API.Link} proof
     * @param {number} index
     * @param {API.Failure} cause
     */
    constructor(proof: API.Link, index: number, cause: API.Failure);
    proof: API.UCAN.Link<any, number, number, 1>;
    index: number;
    cause: API.Failure;
}
export { Failure, UnavailableProof, MalformedCapability, InvalidAudience };
//# sourceMappingURL=lib.d.ts.map